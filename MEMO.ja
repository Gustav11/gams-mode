
Filename:            memo.ja
Author:		     Shiro Takeda
First-written:       <2003/02/21>
Time-stamp:	     <2016-03-02 17:00:43 st>

--------------------------------------------------------------------------

* Emacs が扱える整数の上限は 2**28 = 268435456

* GAMS の数式を TeX の数式に変換する機能を追加する．

* OUTLINE
  数字を表示できるものに関しては数字を表示するようーにする．

* 便利な関数

  - (sit-for 0) は画面を書換えるのに使える。
  
* `memq'、`member'、`assq'、`assoc'のリスト探索基本関数を使うほうが
  明示的な繰り返しよりも速い。これらの探索基本関数の1つを使えるよ
  うにデータ構造を変更する価値はある。
     

説明文字列に関するヒント
========================

説明文字列を書くうえでのヒントや慣習を述べます。コマンド`M-x
checkdoc-minor-mode'を実行して、これらの慣習の多くを確認できます。

   * ユーザーが知っておくことを意図した各コマンド、関数、変数には、説
     明文字列を付けること。

   * Lispプログラムの内部変数やサブルーティンにも説明文字列を付ける。
     Emacsの初期の版では、説明文字列のかわりにコメントを使うと容量を節
     約できたが、今はこれはあてはまらない。

   * 説明文字列の最初の行は、1つか2つの完全な文であり、それだけで概要
     を表していること。`M-x apropos'は説明文字列の最初の行だけを表示す
     るため、それだけで十分に表せないと表示結果が悪くなる。特に、最初
     の行は大文字で始め、ピリオドで終えること。

     説明文字列には、関数や変数の使い方の詳細を述べる追加の行があって
     よい。それらの行も完全な文から成るべきであるが、見ためをよくする
     ために適当に詰めてよい。

   * 一貫性があるように、関数の説明文字列の最初の文の動詞は『to』を省
     いた不定詞にする。たとえば、『Returns the cons of A and B.』では
     なく『Return the cons of A and B.』とする。最初の行の残りの文につ
     いても同様にするとよい。以降の文節では適切な主語があるほうが一般
     にはよい。

   * 説明文字列は受動態ではなく能動態で書き、未来形ではなく現在形で書
     く。たとえば、『A list containing A and B will be returned.』では
     なく『Return a list containing A and B.』と書く。

   * 不必要に単語『cause』（および同義語）を使わないこと。『Cause
     Emacs to display text in boldface,』ではなく単に『Display text in
     boldface.』と書く。

   * 説明文字列は、白文字で始めたり終えないこと。

   * 80コラムのスクリーン上のEmacsのウィンドウに収まるように説明文字列
     を整形する。ほとんどの行を60文字を越えないようにするとよい。必要
     な情報を入れるためならば最初の行が長くなってもよい。

     しかし、説明文字列全体を単純に整形するよりは、注意深く行分けする
     と読みやすくなる。説明文字列が長い場合には、話題ごとに空行で区切
     る。
 
   * ソースコード上で説明文字列の最初の行に揃えるために説明文字列の残
     りの行を字下げ*しないこと*。ソースコード上では見ためがよくても、
     ユーザーが説明文字を見るときには奇妙に見える。文字列を始めるダブ
     ルクォートのまえにある字下げは文字列の一部ではないことに注意！

   * ユーザーが禁止コマンドを実行しようとすると、Emacsは当該コマンドの
     説明文字列の最初の文節、つまり、最初の空行までを表示する。必要な
     らば、最初の空行のまえに入れるべき情報を選んで、このような表示が
     有用であるようにする。

   * ユーザーが対話的に設定したがるような変数では、その変数の説明文字
     列は`*'で始める。変数の値が、長いリストや関数であるとき、あるいは、
     初期化ファイルでのみ設定するような変数であるときには、その説明文
     字列を`*'で始めないこと。*Note Defining Variables::。

   * yes/noのフラグを表す変数の説明文字列は『Non-nil means...』のよう
     な単語で始めて、`nil'以外の値はすべて同値であることを明らかにし、
     `nil'と`nil'以外の意味を明確に示すこと。

   * 関数の説明文字列でその引数について述べるときには、その引数の値を
     表す名前には大文字で書いた引数名を使う。したがって、関数`/'の説明
     文字列では、その第2引数の名前は`divisor'なので、`DIVISOR'と表す。

     また、リストやベクトルを（その一部が変化するかもしれない）構成部
     分に分解したものを示すときなどのメタ変数には、すべて大文字を使う。

   * 説明文字列でLispシンボルを参照するときには、それが表示されるとき
     （つまり普通はすべて小文字）のようにシングルクォートで囲って書く。
     たとえば、`lambda'である。これには2つ例外があり、tとnilはシングル
     クォートで囲まずに書く。（本書では、すべてのシンボルをシングルクォー
     トで囲む別の慣習を用いている。）

     ヘルプモードでは、説明文字列でシングルクォートで囲ったシンボルを
     使うと、そのシンボルに関数定義や変数定義があるときには自動的にハ
     イパーリンクを作成する。この機能を利用するために特別なことをする
     必要はない。しかし、シンボルに関数定義と変数定義の両方があり、ど
     ちらか一方のみを参照したい場合には、シンボルの名前のまえに
     `variable'、`option'、`function'、`command'のいずれかの単語を書く
     だけでどちらであるかを指定できる。（これらの単語を認識するときに
     は大文字小文字は区別しない。）たとえばつぎのように書くと、

          This function sets the variable `buffer-file-name'.

     ハイパーリンクは、変数`buffer-file-name'の説明文字列を指し、その
     関数の説明文字列は指さない。

     シンボルに関数定義や変数定義があっても、説明文字列でのシンボルの
     使い方には無関係な場合には、シンボルの名前のまえに単語`symbol'を
     書けば、ハイパーリンクを作らないようにできる。たとえば、つぎのよ
     うにすると、

          If the argument KIND-OF-RESULT is the symbol `list',
          this function returns a list of all the objects
          that satisfy the criterion.

     ここでは`list'の関数／変数定義は無関係なので、関数`list'の説明文
     字列を指すハイパーリンクは作られない。

   * 説明文字列に直接キー列を書き込まないこと。そのかわりに、それの標
     準的なキー列を作成する`\\[...]'の書き方を使う。たとえば、`C-f'と
     書くかわりに、`\\[forward-char]'と書く。Emacsが説明文字列を表示す
     るときに、`forward-char'に現在バインドされているキーにEmacsが置き
     換える。（普通は`C-f'であるが、ユーザーがキーバインディングを変更
     していれば、別の文字になる。）*Note Keys in Documentation::。

   * メジャーモードの説明文字列では、グローバルなキーマップではなくそ
     のモードのローカルなキーマップでのキーバインディングを参照したい
     だろう。それには、使用するキーマップを指定する構文`\\<...>'を説明
     文字列の中に書く。最初に`\\[...]'を使うまえにこうしておくこと。
     `\\<...>'の内側のテキストは、メジャーモード向けのローカルキーマッ
     プを保持する変数の名前であること。

     説明文字列の表示を遅くしてしまうので、`\\[...]'を何回も使うのは実
     用的ではない。したがって、読者のメジャーモードのもっとも重要なコ
     マンドの記述にこれを使い、モードのキーマップの残りを表示するには
     `\\{...}'を使う。


File: elisp, Node: Compilation Tips

コンパイル済みコードを速くするヒント
====================================

バイトコンパイルしたLispプログラムの実行速度を改良する方法を示します。

   * ライブラリ`profile'やライブラリ`elp'で、読者のプログラムを計測す
     る。操作方法についてはファイル`profile.el'と`elp.el'を参照。

   * 可能な場合には再帰ではなく繰り返しを使う。コンパイル済みの関数が
     別のコンパイル済み関数を呼び出す場合であってもEmacs Lispでは関数
     呼び出しは遅い。

   * `memq'、`member'、`assq'、`assoc'のリスト探索基本関数を使うほうが
     明示的な繰り返しよりも速い。これらの探索基本関数の1つを使えるよう
     にデータ構造を変更する価値はある。

   * ある種の組み込み関数は、バイトコンパイル済みのコードでは普通の関
     数呼び出しを避けるように特別に扱われる。これらの関数を使うのはよ
     いことである。コンパイラが関数を特別に扱うかどうかを調べるには、
     その属性`byte-compile'を調べる。属性が`nil'以外であれば、その関数
     は特別に扱われる。

     たとえば、つぎの入力は、`aref'が特別にコンパイルされることを示す
     （*Note Array Functions::）。

          (get 'aref 'byte-compile)
               => byte-compile-two-args

   * 読者のプログラムの実行時間のかなりの部分を小さな関数の呼び出しが
     占めるときには、その関数をインラインにする。これにより関数呼び出
     しのオーバヘッドを削除できる。関数をインラインにするとプログラム
     変更の柔軟性を減じるので、ユーザーが速度を気にするほど遅い部分の
     十分な速度向上が得られない限り、このようにしないこと。*Note
     Inline Functions::。
  


--------------------
Local Variables:
mode: indented-text
coding: utf-8-dos
fill-column: 74
End:
